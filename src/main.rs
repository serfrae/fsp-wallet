use {
    anyhow::{anyhow, Result},
    clap::{command, Parser, Subcommand},
    directories::BaseDirs,
    solana_cli_config,
    solana_client::rpc_client::RpcClient,
    solana_sdk::{
        commitment_config::CommitmentConfig,
        native_token::sol_to_lamports,
        pubkey::Pubkey,
        signature::{read_keypair_file, Signer},
        signer::keypair::{write_keypair_file, Keypair},
        system_instruction::transfer,
        transaction::Transaction,
    },
    std::{fs, path::PathBuf},
};

#[derive(Parser, Debug)]
struct Cli {
    /// The url for the rpc client, if no option is provided, will default to
    /// the solana config file
    ///
    /// Options:
    /// "l" | "local" for localhost
    /// "d" | "devnet" for devnet
    /// "t" | "testnet" for testnet
    /// "m" | "mainnet" for mainnet-beta
    /// A custom url may be given provided it adheres to proper formatting
    /// else the program will fail
    url: Option<String>,
    #[command(subcommand)]
    cmd: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Generate a new keypair
    #[command(subcommand)]
    Keypair(KeypairOptions),
    /// Airdrop the requested amount of SOL (this will fail on mainnet).
    Airdrop {
        /// Specify a wallet to airdrop solana tokens to, defaults to the keypair generated
        /// by this program or if `None` will default to the keypair found in the solana config
        /// file
        to: Option<Pubkey>,
        /// Amount of SOL to be airdropped
        amount: f64,
    },
    /// Attempts to transfer the requested amount of SOL from the generated keypair
    Transfer {
        /// Path to keypair file to transfer SOL from, if `None` then will default to the one
        /// generated by this program, if no keypair has been generated by this program or the
        /// generated keypair is not in the expected folder, it will default to the keypair
        /// found in the solana config file
        from: Option<PathBuf>,
        /// Pubkey of the recipient of this transfer
        to: Pubkey,
        amount: f64,
    },
}

/// Generate a new keypair (may also remove the folder created by this program when generating
/// a keypair to clean-up after done)
#[derive(Subcommand, Debug)]
enum KeypairOptions {
    /// Creates a new keypair at the default configuration directory depending
    /// on your operating system - for unix-based systems this will be
    /// $XDG_CONFIG_HOME/fsp-wallet/keypair.json for windows systems the target is
    /// %APPDATA%\fsp-wallet\keypair.json
    New { outfile: Option<PathBuf> },
    /// Removes folder generated by this program
    Remove,
}

fn main() -> Result<()> {
    let args = Cli::parse();

    let solana_config_file = if let Some(ref config) = *solana_cli_config::CONFIG_FILE {
        solana_cli_config::Config::load(config).unwrap_or_default()
    } else {
        solana_cli_config::Config::default()
    };

    let rpc_url = if let Some(url) = args.url {
        match url.as_str() {
            "l" | "localhost" => "http://localhost:8899".to_string(),
            "d" | "devnet" => "https://devnet.solana.com".to_string(),
            "t" | "testnet" => "https://testnet.solana.com".to_string(),
            "m" | "mainnet" => "https://mainnet-beta.solana.com".to_string(),
            _ => url.to_string(),
        }
    } else {
        solana_config_file.json_rpc_url.to_string()
    };

    let rpc_client = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

    match args.cmd {
        Commands::Keypair(fields) => match fields {
            KeypairOptions::New { outfile } => {
                let keypair = create_keypair_file(outfile.as_ref())?;
                println!("{}", keypair.pubkey());
            }
            KeypairOptions::Remove => delete_folder()?,
        },
        Commands::Airdrop { to, amount } => {
            let to = if let Some(to) = to {
                to
            } else {
                {
                    if let Ok(keypair) = get_keypair_file(None) {
                        keypair
                    } else {
                        read_keypair_file(solana_config_file.keypair_path)
                            .map_err(|e| anyhow!("Failed to get a keypair: {}", e))?
                    }
                }
                .pubkey()
            };

            let latest_blockhash = rpc_client
                .get_latest_blockhash()
                .map_err(|e| anyhow!("Unable to get latest blockhash: {}", e))?;

            let transaction = rpc_client.request_airdrop_with_blockhash(
                &to,
                sol_to_lamports(amount),
                &latest_blockhash,
            )?;

            rpc_client.confirm_transaction_with_spinner(
                &transaction,
                &latest_blockhash,
                CommitmentConfig::confirmed(),
            )?;
        }
        Commands::Transfer { from, to, amount } => {
            let from = if let Ok(keypair) = get_keypair_file(from.as_ref()) {
                keypair
            } else {
                read_keypair_file(solana_config_file.keypair_path)
                    .map_err(|e| anyhow!("Failed to get a keypair: {}", e))?
            };

            let ix = transfer(&from.pubkey(), &to, sol_to_lamports(amount));

            let mut transaction = Transaction::new_with_payer(&[ix], Some(&from.pubkey()));

            let latest_blockhash = rpc_client
                .get_latest_blockhash()
                .map_err(|err| anyhow!("Unable to get latest blockhash: {}", err))?;

            transaction.sign(&[&from], latest_blockhash);

            let txid = rpc_client
                .send_and_confirm_transaction_with_spinner(&transaction)
                .map_err(|err| anyhow!("Unable to send transaction: {}", err))?;
            println!("TXID: {}", txid);
        }
    };

    Ok(())
}

/// Looks for the config file if one doesn't exist, attempts to create it
fn get_folder() -> Result<PathBuf> {
    let path = get_path()?;

    if !path.exists() {
        fs::create_dir_all(&path).map_err(|e| anyhow!("Error creating folder: {}", e))?;
        return Ok(path);
    }

    Ok(path)
}

fn delete_folder() -> Result<()> {
    let path = get_path()?;

    if path.exists() {
        fs::remove_dir_all(path).map_err(|e| anyhow!("Could not remove directory: {}", e))
    } else {
        Ok(())
    }
}

fn get_path() -> Result<PathBuf> {
    let path = BaseDirs::new().map(|base_dirs| base_dirs.config_dir().join("fsp-wallet"));
    match path {
        Some(path) => Ok(path),
        None => Err(anyhow!("Error getting path")),
    }
}

/// Looks for the specified keypair file, if `None` defaults to keypair in this program's config
/// else returns an error
fn get_keypair_file(path: Option<&PathBuf>) -> Result<Keypair> {
    if let Some(path) = path {
        if path.exists() {
            return read_keypair_file(&path).map_err(|e| {
                anyhow!("Could not create keypair file at {}: {}", path.display(), e)
            });
        } else {
            return Err(anyhow!("Invalid path: {}", path.display()));
        }
    } else {
        return read_keypair_file(get_folder()?.join("fsp-wallet.json"))
            .map_err(|e| anyhow!("Could not read default keypair: {}", e));
    }
}

fn create_keypair_file(path: Option<&PathBuf>) -> Result<Keypair> {
    let keypair = Keypair::new();
    if let Some(path) = path {
        if path.exists() {
            let _ = write_keypair_file(&keypair, &path);
            return Ok(keypair);
        } else {
            return Err(anyhow!("Invalid path: {}", path.display()));
        }
    } else {
        let _ = write_keypair_file(&keypair, get_folder()?)
            .map_err(|e| anyhow!("Could not write keypair: {}", e));
        Ok(keypair)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_get_folder() {
    }
}
