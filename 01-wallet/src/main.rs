use {
    anyhow::{anyhow, Result},
    clap::{command, Parser, Subcommand},
    directories::BaseDirs,
    solana_cli_config,
    solana_client::rpc_client::RpcClient,
    solana_sdk::{
        bs58,
        commitment_config::CommitmentConfig,
        native_token::{lamports_to_sol, sol_to_lamports},
        pubkey::Pubkey,
        signature::{read_keypair_file, Signer},
        signer::keypair::{write_keypair_file, Keypair},
        system_instruction::transfer,
        transaction::Transaction,
    },
    std::{fs, path::PathBuf},
};

#[derive(Parser, Debug)]
struct Cli {
    /// The url for the rpc client, if no option is provided, will default to
    /// the solana config file
    ///
    /// Options:
    /// "l" | "local" for localhost
    /// "d" | "devnet" for devnet
    /// "t" | "testnet" for testnet
    /// "m" | "mainnet" for mainnet-beta
    /// A custom url may be given provided it adheres to proper formatting
    /// else the program will fail
    url: Option<String>,
    #[command(subcommand)]
    cmd: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Generate a new keypair
    #[command(subcommand)]
    Keypair(KeypairOptions),

    /// Retrieve the public or private key of the specified keypair
    #[command(subcommand)]
    Address(AddressOptions),

    /// Get the SOL balance of the specified keypair, if `None` reverts to default
    Balance {
        pubkey: Option<Pubkey>,
    },

    /// Airdrop the requested amount of SOL (this will fail on mainnet).
    Airdrop {
        /// Specify a wallet to airdrop solana tokens to, defaults to the keypair generated
        /// by this program or if `None` will default to the keypair found in the solana config
        /// file
        #[arg(long, short)]
        to: Option<Pubkey>,
        /// Amount of SOL to be airdropped
        amount: f64,
    },
    /// Attempts to transfer the requested amount of SOL from the generated keypair
    Transfer {
        /// Path to keypair file to transfer SOL from, if `None` then will default to the one
        /// generated by this program, if no keypair has been generated by this program or the
        /// generated keypair is not in the expected folder, it will default to the keypair
        /// found in the solana config file
        #[arg(long, short)]
        from: Option<PathBuf>,
        /// Pubkey of the recipient of this transfer
        to: Pubkey,
        amount: f64,
    },
}

/// Generate a new keypair (may also remove the folder created by this program when generating
/// a keypair to clean-up after done)
#[derive(Subcommand, Debug)]
enum KeypairOptions {
    /// Creates a new keypair at the default configuration directory depending
    /// on your operating system - for unix-based systems this will be
    /// $XDG_CONFIG_HOME/fsp-wallet/keypair.json for windows systems the target is
    /// %APPDATA%\fsp-wallet\keypair.json
    New {
        #[arg(long, short)]
        outfile: Option<PathBuf>,
    },
    /// Removes folder generated by this program
    Remove,
}

#[derive(Subcommand, Debug)]
enum AddressOptions {
    Public {
        /// The path of the keypair file, if `None` returns the default
        #[arg(long, short)]
        keypair: Option<PathBuf>,
    },

    Secret {
        /// The path of the keypair file, if `None` returns the default
        #[arg(long, short)]
        keypair: Option<PathBuf>,
        /// provide argument "base58" for base58 encoded private key, or no argument for
        /// default byte array
        #[arg(long, short)]
        as_type: Option<String>,
    },
}

fn main() -> Result<()> {
    let args = Cli::parse();

    let solana_config_file = if let Some(ref config) = *solana_cli_config::CONFIG_FILE {
        solana_cli_config::Config::load(config).unwrap_or_default()
    } else {
        solana_cli_config::Config::default()
    };

    let rpc_url = if let Some(url) = args.url {
        match url.as_str() {
            "l" | "localhost" => "http://localhost:8899".to_string(),
            "d" | "devnet" => "https://devnet.solana.com".to_string(),
            "t" | "testnet" => "https://testnet.solana.com".to_string(),
            "m" | "mainnet" => "https://mainnet-beta.solana.com".to_string(),
            _ => url.to_string(),
        }
    } else {
        solana_config_file.json_rpc_url.to_string()
    };

    let rpc_client = RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed());

    match args.cmd {
        Commands::Keypair(fields) => match fields {
            KeypairOptions::New { outfile } => {
                let keypair = create_keypair_file(outfile.as_ref())?;
                println!("{}", keypair.pubkey());
            }
            KeypairOptions::Remove => delete_folder()?,
        },
        Commands::Address(address_options) => match address_options {
            AddressOptions::Public { keypair } => {
                let pubkey = if let Ok(kp) = get_keypair_file(keypair.as_ref()) {
                    kp.pubkey()
                } else {
                    read_keypair_file(solana_config_file.keypair_path)
                        .map_err(|e| anyhow!("Failed to get keypair file: {}", e))?
                        .pubkey()
                };

                println!("Pubkey: {}", pubkey);
            }
            AddressOptions::Secret { keypair, as_type } => {
                let secret = if let Ok(kp) = get_keypair_file(keypair.as_ref()) {
                    kp
                } else {
                    read_keypair_file(solana_config_file.keypair_path)
                        .map_err(|e| anyhow!("Failed to get keypair file: {}", e))?
                }
                .secret()
                .to_bytes();

                println!(
                    "Secret key: {}",
                    if let Some(_) = as_type {
                        bs58::encode(secret).into_string()
                    } else {
                        format!("{:?}", secret)
                    }
                )
            }
        },
        Commands::Balance { pubkey } => {
            let pubkey = if pubkey.is_none() {
                if let Ok(kp) = get_keypair_file(None) {
                    kp
                } else {
                    read_keypair_file(solana_config_file.keypair_path)
                        .map_err(|e| anyhow!("Failed to get keypair file: {}", e))?
                }
                .pubkey()
            } else {
                pubkey.unwrap()
            };

            let balance = rpc_client.get_balance(&pubkey)?;
            println!("Balance: {} SOL", lamports_to_sol(balance));
        }
        Commands::Airdrop { to, amount } => {
            let to = if let Some(to) = to {
                to
            } else {
                {
                    if let Ok(kp) = get_keypair_file(None) {
                        kp
                    } else {
                        read_keypair_file(solana_config_file.keypair_path)
                            .map_err(|e| anyhow!("Failed to get a keypair: {}", e))?
                    }
                }
                .pubkey()
            };

            let latest_blockhash = rpc_client
                .get_latest_blockhash()
                .map_err(|e| anyhow!("Unable to get latest blockhash: {}", e))?;

            let tx = rpc_client.request_airdrop_with_blockhash(
                &to,
                sol_to_lamports(amount),
                &latest_blockhash,
            )?;

            rpc_client.confirm_transaction_with_spinner(
                &tx,
                &latest_blockhash,
                CommitmentConfig::confirmed(),
            )?;
        }
        Commands::Transfer { from, to, amount } => {
            let from = if let Ok(kp) = get_keypair_file(from.as_ref()) {
                kp
            } else {
                read_keypair_file(solana_config_file.keypair_path)
                    .map_err(|e| anyhow!("Failed to get a keypair: {}", e))?
            };

            let ix = transfer(&from.pubkey(), &to, sol_to_lamports(amount));

            let mut tx = Transaction::new_with_payer(&[ix], Some(&from.pubkey()));

            let latest_blockhash = rpc_client
                .get_latest_blockhash()
                .map_err(|err| anyhow!("Unable to get latest blockhash: {}", err))?;

            tx.sign(&[&from], latest_blockhash);

            let txid = rpc_client
                .send_and_confirm_transaction_with_spinner(&tx)
                .map_err(|err| anyhow!("Unable to send transaction: {}", err))?;
            println!("TXID: {}", txid);
        }
    };

    Ok(())
}

/// Looks for the config file if one doesn't exist, attempts to create it
fn get_folder() -> Result<PathBuf> {
    let path = get_path()?;

    if !path.exists() {
        fs::create_dir_all(&path).map_err(|e| anyhow!("Error creating folder: {}", e))?;
        return Ok(path);
    }

    Ok(path)
}

fn delete_folder() -> Result<()> {
    let path = get_path()?;

    if path.exists() {
        fs::remove_dir_all(path).map_err(|e| anyhow!("Could not remove directory: {}", e))
    } else {
        Ok(())
    }
}

fn get_path() -> Result<PathBuf> {
    let path = BaseDirs::new().map(|base_dirs| base_dirs.config_dir().join("fsp-wallet"));
    match path {
        Some(path) => Ok(path),
        None => Err(anyhow!("Error getting path")),
    }
}

/// Looks for the specified keypair file, if `None` defaults to keypair in this program's config
/// else returns an error
fn get_keypair_file(path: Option<&PathBuf>) -> Result<Keypair> {
    let file_path = if let Some(path) = path {
        if path.exists() {
            path.to_path_buf()
        } else {
            return Err(anyhow!("Invalid path: {}", path.display()));
        }
    } else {
        get_folder()?.join("fsp-wallet.json")
    };

    read_keypair_file(&file_path).map_err(|e| {
        anyhow!(
            "Could not read keypair file at {}: {}",
            file_path.display(),
            e
        )
    })
}

fn create_keypair_file(path: Option<&PathBuf>) -> Result<Keypair> {
    let keypair = Keypair::new();

    let file_path = if let Some(path) = path {
        println!("Creating keypair at: {}", path.display());
        path.to_path_buf()
    } else {
        get_folder()?.join("fsp-wallet.json")
    };

    write_keypair_file(&keypair, &file_path)
        .map_err(|e| anyhow!("Could not write keypair to {}: {}", file_path.display(), e))?;

    Ok(keypair)
}
